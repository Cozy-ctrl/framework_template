/**
 * Command execution implementation - mirrors Node.js child_process API
 */
import { EventEmitter } from 'node:events';
import { Readable, Writable } from 'node:stream';
import type { Sprite } from './sprite.js';
import type { SpawnOptions, ExecOptions, ExecResult } from './types.js';
/**
 * Represents a command running on a sprite
 * Mirrors the Node.js ChildProcess API
 */
export declare class SpriteCommand extends EventEmitter {
    private sprite;
    readonly stdin: Writable;
    readonly stdout: Readable;
    readonly stderr: Readable;
    private wsCmd;
    private exitPromise;
    private exitResolver;
    private started;
    constructor(sprite: Sprite, command: string, args?: string[], options?: SpawnOptions);
    /**
     * Start the command execution
     */
    start(): Promise<void>;
    /**
     * Set up stream connections
     */
    private setupStreams;
    /**
     * Build WebSocket URL with query parameters
     */
    private buildWebSocketURL;
    /**
     * Wait for the command to complete and return the exit code
     */
    wait(): Promise<number>;
    /**
     * Kill the command
     */
    kill(_signal?: string): void;
    /**
     * Resize the terminal (TTY mode only)
     */
    resize(cols: number, rows: number): void;
    /**
     * Get the exit code (returns -1 if not exited)
     */
    exitCode(): number;
}
/**
 * Spawn a command - event-based API (most Node.js-like)
 */
export declare function spawn(sprite: Sprite, command: string, args?: string[], options?: SpawnOptions): SpriteCommand;
/**
 * Execute a command and return a promise with the output
 */
export declare function exec(sprite: Sprite, command: string, options?: ExecOptions): Promise<ExecResult>;
/**
 * Execute a file with arguments and return a promise with the output
 */
export declare function execFile(sprite: Sprite, file: string, args?: string[], options?: ExecOptions): Promise<ExecResult>;
//# sourceMappingURL=exec.d.ts.map